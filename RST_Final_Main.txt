import pandas as pd
import numpy as np
from Pandas_Age_Walk_Function_Class import PandasAgeWalkFunc
from itertools import combinations
import pygal


# accepting file_path
flag = False
while not flag:
    file_path = input("Please enter the complete correct file path of the dataset: \n")
    ch = (input("Press 'Y' to confirm \nPress 'N' to enter file path again \n")).upper()
    if ch == 'Y':
        flag = True
    elif ch == 'N':
        flag = False

df = pd.read_csv(file_path, index_col=0)    # reading csv file data as a data frame variable
print(df)
print()

index = df.index
columns = df.columns
values = df.values
num_col = df.shape[1]
num_row = df.shape[0]


obj_elem_set = set()    # stores serial number of each object as set elements
for i in range(1, df.shape[0]+1):
    obj_elem_set.add(i)
print(obj_elem_set)
print()

# storage variables used
dict_col = {}   # stores cardinal nos. of element values column-wise as well as unique data-wise
elemen_list = []    # stores elementary list numbers of conditional attributes
cris_list = []  # stores crisp set numbers of decision attribute
list_col = []   # stores names of columns
list_combi = []     # stores combinations of columns as tuples
elem_indiscern_2_list = []  # stores List of all indiscernible combinations taking double conditional attributes
elem_list = []  # stores elementary set numbers of conditional attributes
dict_low = {}   # stores lower bound set
dict_upp = {}   # stores upper bound set
dict_accu = {}  # stores accuracy of each combinations
dict_boun = {}  # stores boundary region of each combinations
dict_out = {}   # stores outside region of each combinations
elem_dict = {}  # stores elementary list and dict numbers of conditional attributes
elemen_dict = {}    # stores elementary dict numbers of conditional attributes
dict_indiscern_2 = {}   # stores elementary list for double conditional attributes


for column in columns:  # stores names of columns
    list_col.append(column)
list_col.pop()  # don't include decision attribute (last column)

len_combi = num_col - 1
col_combi = combinations(list_col, len_combi)   # stores combinations of columns taken 'len_combi' at a time
list_combi = list(col_combi)    # stores combinations of columns as tuples
print(list_combi)


# PandasAgeWalkFunc class object created
obj_item = PandasAgeWalkFunc(df)

# obtain complete serial numbers of all unique conditional and decision attributes as a dictionary
dict_col = obj_item.col_item_split()
print(dict_col)

# obtain elementary set and crisp set
elem_dict = obj_item.elem_list(dict_col)
elemen_list = elem_dict['Elem List']
cris_list = elemen_list.pop()
elemen_dict = elem_dict['Elem Dict']
rem_key = columns[-1]
elemen_dict.pop(rem_key)


print("Elementary List for Single-Conditional Attributes: \n" + str(elemen_list) + "\n")
print("Crisp List: " + str(cris_list) + "\n")
print("Elementary Dictionary: " + str(elemen_dict) + "\n")

# Returns elementary list for multiple conditional attributes
dict_indiscern_2 = obj_item.column_combinations(elemen_dict, list_combi)
print("List of all indiscernible combinations taking multiple conditional attributes is as follows: ")
print(str(dict_indiscern_2) + "\n")

for val in dict_indiscern_2.values():
    elem_indiscern_2_list.append(val)
print("Elementary List for Double-Conditional Attributes: \n" + str(elem_indiscern_2_list) + "\n")
elem_list = elem_indiscern_2_list   # for multiple conditional attributes

# obtain lower and upper approximations
dec_val = input("Enter decision attribute value to be calculated: ")
dict_low = obj_item.low_approx(dec_val, dict_col, elem_list, list_combi)
print(str(dict_low) + "\n")
dict_upp = obj_item.upp_approx(dec_val, dict_col, elem_list, list_combi)
print(str(dict_upp) + "\n")

# obtain accuracy parameter using accuracy = nLa/nUa
dict_accu = obj_item.get_accu(dict_low, dict_upp)
print("Accuracy of the parameters for the chosen decision attribute is given below: ")
print(str(dict_accu) + "\n")

# get boundary region
dict_boun = obj_item.get_boundary(dict_low, dict_upp)
print("Boundary region is: Upper Approx. - Lower Approx. = ")
print(str(dict_boun) + "\n")

# get outside region
dict_out = obj_item.get_outside_region(obj_elem_set, dict_upp)
print("Outside region is: Universal Set - Upper Approx: ")
print(str(dict_out) + "\n")

chart = pygal.Line()
chart.force_uri_protocol = 'http'
chart.title = "Accuracy of Conditional Attributes"
x_values = list(range(11))
chart.x_labels = x_values
chart.x_title = "Time"
chart.y_title = "Accuracy"

for key, value in dict_accu.items():
    ind = str(key)
    chart.add(ind, value)

chart.render_to_file('accuracy_conditional_attributes.svg')



# df['Fit'] = df['Walk'].apply(lambda x: x == 'Yes')
# print(df)


# col_items = df.Age.unique() # numpy library function
# col_items.append(len(col_items))   # doesn't work since it returns a numpy array
# dict_col = {col_items}


# for i in range(1, df.shape[1]):   direction function unique() exists
#    obj_item = Pandas_Age_Walk_Func(values, i)
#    dict_col[i] = obj_item.get_col_items()    # default keys provided - 1,2,...
# print(sorted(set(df.Age.unique())))   # converts numpy unique() array to set; set stores every value only once

