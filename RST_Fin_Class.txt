import pandas as pd
from itertools import combinations


class PandasAgeWalkFunc:

    global dict_combo, dict_col_all, list_keys, dict_col, col_items, index, columns, values, num_rows, num_cols, dict_boundary, dict_outside, col_combi, list_col, dict_lenwise
    col_items = []
    list_keys = []
    col_combi = []
    list_col = []
    dict_keys = {}
    dict_col_all = {}
    dict_boundary = {}
    dict_outside = {}
    dict_lenwise = {}

    def __init__(self, data): # two underscores on either side of __init__
        self.data = data

    def col_item_split(self):

        columns = self.data.columns
        num_rows = self.data.shape[0]

        for column in columns:
            dict_keys = {}
            col_items = sorted(list(set(self.data[column].unique())))   # Forms a list of each unique entry
            # print(col_items)
            # print()
            ser = pd.Series(self.data[column])  # Converts each column entry and its elements into a series
            # print(ser)
            # print()
            for i in range(0, len(col_items)):  # calculates elementary set for single conditional attribute/each column
                list_keys = []
                for j in range(0, num_rows):
                    if ser[j] == col_items[i]:  # compares each entry in a column with each unique column entry
                        list_keys.append((j + 1))   # forms a list of indiscernible entries
                        # print(ser[j] + ', ' + col_items[i])
                        # print(list_keys)
                dict_keys[col_items[i]] = set(list_keys)    # stores elementary sets of the current entry for single CA
            dict_col_all[column] = dict_keys  # stores each column's elementary sets for single cond. attr.
            # print(dict_keys)
            # print()
            # print(dict_col_all)
            # print()

        return dict_col_all

    def elem_list(self, dict_col_all):

        list_all = []
        dict_elem = {}
        dict_combi = {}
        columns = self.data.columns

        for key, value in dict_col_all.items():
            list_col = []
            # print(value)
            # print()
            for val in value.values():  # value itself is a dictionary; accessing value's values
                list_col.append(val)    # stores serial nos. of elementary sets for each unique column entry
                # print(val)
                # print()
            list_all.append(list_col)   # stores lists of serial nos. per unique column entries
            dict_elem[key] = list_col

        dict_combi['Elem Dict'] = dict_elem
        dict_combi['Elem List'] = list_all
        return dict_combi

    def low_approx(self, dec_value, dict_col_all, ele_list, list_col):   # lower approximation calculation

        columns = self.data.columns
        dict_low_approx = {}
        low_apr = set()
        num_cols = self.data.shape[1]
        i = 0
        ctr = 0  # used to check null set condition
        flag = False  # used to check null set condition
        test = dict_col_all[columns[num_cols - 1]]  # stores the decision attribute entries
        sup_set = test[dec_value]  # contains serial nos. set of decision value to be tested

        print("Lower Approximations are given below: ")
        for elem in ele_list:  # iterate through each column element list
            for se in elem:  # iterate through unique serial nos. list
                if se.issubset(sup_set):    # check for condition of la
                    flag = True
                    ctr += 1
                    if flag:
                        low_apr.update(se)
                        flag = False
            dict_low_approx[list_col[i]] = set(list(low_apr))   # stores la for each cond. attr.
            if not flag and ctr == 0:  # to check and return for null_set condition
                dict_low_approx[list_col[i]] = {}
            low_apr.clear()
            low_apr = set()
            i += 1
            # print(dict_low_approx)

        return dict_low_approx

    def upp_approx(self, dec_value, dict_col_all, ele_list, list_col):   # upper approximations calculation

        columns = self.data.columns
        dict_upp_approx = {}
        num_cols = self.data.shape[1]
        i = 0
        test = dict_col_all[columns[num_cols - 1]]  # stores either of the values of the decision value to be tested
        sup_set = test[dec_value]  # contains cardinal nos. set of decision value
        upp_apr = sup_set.copy()    # since ua comprises of at least chosen decision value's serial nos.

        print("Upper Approximations are given below: ")
        for elem in ele_list:  # iterate through each column element list
            for se in elem:  # iterate through unique serial nos. list
                if not se.isdisjoint(sup_set):  # check for condition of ua
                    upp_apr.update(se)
            dict_upp_approx[list_col[i]] = set(list(upp_apr))   # stores ua for each cond. attr.
            upp_apr.clear()
            upp_apr = sup_set.copy()
            i += 1

        return dict_upp_approx

    def get_accu(self, dict_la, dict_ua):

        dict_accuracy = {}
        n_la = 0
        n_ua = 0
        acc = 0.0

        for key in dict_la.keys():  # length of either dict_la or dict_ua; both are equal to no. of CAs taken at a time
            n_la = len(dict_la[key])    # no. of elements in la
            n_ua = len(dict_ua[key])    # no. of elements in ua
            acc = n_la/n_ua             # calculates accuracy for each CAs taken at a time
            dict_accuracy[key] = acc
            # print(key + " : " + str(n_la) + " / " + str(n_ua) + " = " + str(acc))

        return dict_accuracy

    def get_boundary(self, dict_la, dict_ua):

        for key in dict_la.keys():
            dict_boundary[key] = dict_ua[key].difference(dict_la[key])  # boundary region = ua - la

        return dict_boundary

    def get_outside_region(self, elem_set, dict_ua):

        temp_set = set()
        for key in dict_ua.keys():
            temp_set = elem_set.difference(dict_ua[key])    # outside region = U - ua
            if temp_set == set():
                dict_outside[key] = {}
            else:
                dict_outside[key] = temp_set

        return dict_outside

    def column_combinations(self, elem_dict, list_col_combi, len_comb):

        dict_intersect = {}
        list_intersect = []
        temp_list = []
        list_swap = []
        columns = self.data.columns
        for column in columns:
            list_col.append(column)
        list_col.pop()

        for combo in list_col_combi:   # for each combination of columns
            temp_list = []
            list_swap = elem_dict[combo[0]]
            for elem in range(1, len_comb):  # for each column in a combination tuple
                temp_list = elem_dict[combo[elem]]
                for se in list_swap:
                    for s in temp_list:
                        temp_set = se
                        temp_set = temp_set.intersection(s)
                        if temp_set != set():
                            list_intersect.append(temp_set)
            dict_intersect[combo] = list_intersect
            list_intersect = []

        return dict_intersect


# set_age = []
# ctr_age = 0
# for value in values:
#     if value[1] not in set_age:
#         set_age.append(value[1])
#         ctr_age += 1
#
#
# print(set_age)
# print(ctr_age)
#    def get_col_items_nump(self):
#        items = []
#        ctr = 0

#       for value in self.values:
#            if value[self.x] not in items:
#                items.append(value[self.x])
#                ctr += 1
#        dict_combo = {'item': items, 'count': ctr}
#        items = []
#        ctr = 0
#        return dict_combo
